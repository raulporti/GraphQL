{"ast":null,"code":"/**\r\n * Produces the value of a block string from its parsed raw value, similar to\r\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\r\n *\r\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\r\n */\nexport function dedentBlockStringValue(rawString) {\n  // Expand a block string's raw value into independent lines.\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\n\n  var commonIndent = getBlockStringIndentation(lines);\n\n  if (commonIndent !== 0) {\n    for (var i = 1; i < lines.length; i++) {\n      lines[i] = lines[i].slice(commonIndent);\n    }\n  } // Remove leading and trailing blank lines.\n\n\n  while (lines.length > 0 && isBlank(lines[0])) {\n    lines.shift();\n  }\n\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\n    lines.pop();\n  } // Return a string of the lines joined with U+000A.\n\n\n  return lines.join('\\n');\n} // @internal\n\nexport function getBlockStringIndentation(lines) {\n  var commonIndent = null;\n\n  for (var i = 1; i < lines.length; i++) {\n    var line = lines[i];\n    var indent = leadingWhitespace(line);\n\n    if (indent === line.length) {\n      continue; // skip empty lines\n    }\n\n    if (commonIndent === null || indent < commonIndent) {\n      commonIndent = indent;\n\n      if (commonIndent === 0) {\n        break;\n      }\n    }\n  }\n\n  return commonIndent === null ? 0 : commonIndent;\n}\n\nfunction leadingWhitespace(str) {\n  var i = 0;\n\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\n    i++;\n  }\n\n  return i;\n}\n\nfunction isBlank(str) {\n  return leadingWhitespace(str) === str.length;\n}\n/**\r\n * Print a block string in the indented block form by adding a leading and\r\n * trailing blank line. However, if a block string starts with whitespace and is\r\n * a single-line, adding a leading blank line would strip that whitespace.\r\n */\n\n\nexport function printBlockString(value) {\n  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  var isSingleLine = value.indexOf('\\n') === -1;\n  var hasLeadingSpace = value[0] === ' ' || value[0] === '\\t';\n  var hasTrailingQuote = value[value.length - 1] === '\"';\n  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || preferMultipleLines;\n  var result = ''; // Format a multi-line block quote to account for leading space.\n\n  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {\n    result += '\\n' + indentation;\n  }\n\n  result += indentation ? value.replace(/\\n/g, '\\n' + indentation) : value;\n\n  if (printAsMultipleLines) {\n    result += '\\n';\n  }\n\n  return '\"\"\"' + result.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\n}","map":{"version":3,"sources":["D:/Users/Raul/Desktop/GraphQL/cliente/node_modules/graphql/language/blockString.mjs"],"names":["dedentBlockStringValue","rawString","lines","split","commonIndent","getBlockStringIndentation","i","length","slice","isBlank","shift","pop","join","line","indent","leadingWhitespace","str","printBlockString","value","indentation","arguments","undefined","preferMultipleLines","isSingleLine","indexOf","hasLeadingSpace","hasTrailingQuote","printAsMultipleLines","result","replace"],"mappings":"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","sourcesContent":["/**\r\n * Produces the value of a block string from its parsed raw value, similar to\r\n * CoffeeScript's block string, Python's docstring trim or Ruby's strip_heredoc.\r\n *\r\n * This implements the GraphQL spec's BlockStringValue() static algorithm.\r\n */\r\nexport function dedentBlockStringValue(rawString) {\r\n  // Expand a block string's raw value into independent lines.\r\n  var lines = rawString.split(/\\r\\n|[\\n\\r]/g); // Remove common indentation from all lines but first.\r\n\r\n  var commonIndent = getBlockStringIndentation(lines);\r\n\r\n  if (commonIndent !== 0) {\r\n    for (var i = 1; i < lines.length; i++) {\r\n      lines[i] = lines[i].slice(commonIndent);\r\n    }\r\n  } // Remove leading and trailing blank lines.\r\n\r\n\r\n  while (lines.length > 0 && isBlank(lines[0])) {\r\n    lines.shift();\r\n  }\r\n\r\n  while (lines.length > 0 && isBlank(lines[lines.length - 1])) {\r\n    lines.pop();\r\n  } // Return a string of the lines joined with U+000A.\r\n\r\n\r\n  return lines.join('\\n');\r\n} // @internal\r\n\r\nexport function getBlockStringIndentation(lines) {\r\n  var commonIndent = null;\r\n\r\n  for (var i = 1; i < lines.length; i++) {\r\n    var line = lines[i];\r\n    var indent = leadingWhitespace(line);\r\n\r\n    if (indent === line.length) {\r\n      continue; // skip empty lines\r\n    }\r\n\r\n    if (commonIndent === null || indent < commonIndent) {\r\n      commonIndent = indent;\r\n\r\n      if (commonIndent === 0) {\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  return commonIndent === null ? 0 : commonIndent;\r\n}\r\n\r\nfunction leadingWhitespace(str) {\r\n  var i = 0;\r\n\r\n  while (i < str.length && (str[i] === ' ' || str[i] === '\\t')) {\r\n    i++;\r\n  }\r\n\r\n  return i;\r\n}\r\n\r\nfunction isBlank(str) {\r\n  return leadingWhitespace(str) === str.length;\r\n}\r\n/**\r\n * Print a block string in the indented block form by adding a leading and\r\n * trailing blank line. However, if a block string starts with whitespace and is\r\n * a single-line, adding a leading blank line would strip that whitespace.\r\n */\r\n\r\n\r\nexport function printBlockString(value) {\r\n  var indentation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\r\n  var preferMultipleLines = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\r\n  var isSingleLine = value.indexOf('\\n') === -1;\r\n  var hasLeadingSpace = value[0] === ' ' || value[0] === '\\t';\r\n  var hasTrailingQuote = value[value.length - 1] === '\"';\r\n  var printAsMultipleLines = !isSingleLine || hasTrailingQuote || preferMultipleLines;\r\n  var result = ''; // Format a multi-line block quote to account for leading space.\r\n\r\n  if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {\r\n    result += '\\n' + indentation;\r\n  }\r\n\r\n  result += indentation ? value.replace(/\\n/g, '\\n' + indentation) : value;\r\n\r\n  if (printAsMultipleLines) {\r\n    result += '\\n';\r\n  }\r\n\r\n  return '\"\"\"' + result.replace(/\"\"\"/g, '\\\\\"\"\"') + '\"\"\"';\r\n}\r\n"]},"metadata":{},"sourceType":"module"}